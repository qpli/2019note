## 第2章 Java内存区域与内存溢出异常
### 2.2 Java运行时数据区域： 
 方法区、虚拟机栈、本地方法栈、堆、程序计数器
#### 2.2.1 程序计数器
是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
每个线程都有一个独立的程序计数器，为“线程私有的”；
如果线程执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果是native方法，这个计数器为空（Undefined）；
是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#### 2.2.2 Java虚拟机栈
线程私有的；生命周期与线程相同。
虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至完成的过程，就会对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

常说的栈指的是虚拟机栈中的局部变量表：局部变量表存储了编译器可知的各种
基本数据类型（Boolean、byte、char、short、int、float、long、double）、对象引用）；

reference类型，它不等同与对象本身，可能是一个指向对象存储的起始地址的引用指针，也可能是指向一个对象的句柄或者其他与此对象相关的位置；

returnAddress类型（指向了一条字节码指令地址）

StackOverflowError异常：线程申请的栈深度大于虚拟机所允许的深度；

OutOfMemoryError异常：扩展时无法申请到足够的内存

#### 2.2.3 本地方法栈
与虚拟机栈类似，虚拟机栈是执行Java字节码方法时的栈，本地方法栈是执行native方法的栈，具体的虚拟机对本地方法栈的实现不同，例如Sun HotSpot对这两个不区分。

#### 2.2.4 Java堆

Java堆是Java虚拟机所管理的最大的一块内存区域，是被所有线程共享的，在虚拟机启动时候创建，用于存放对象实例，几乎所有的对象实例都是在这里分配内存的。

Java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的就可以了。

#### 2.2.5 方法区
各个线程共享的区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

这部分垃圾回收目标主要是常量池和类型的卸载，但是回收成绩比较难以令人满意，尤其是类的卸载，条件非常苛刻，但是这部分的回收是有必要的。

#### 2.2.6 运行时常量池
是方法区的一部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，
这部分内容将在类加载后进入方法去的运行时常量池中存放，如String类的intern()方法。



